\section{РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ}
\label{sec:modules}

При разработке данного программного обеспечения было необходимо реализовать возможность настройки и тестирования
набора устройств. С учетом дальнейшей возможности расширения списка устройств, с которыми должно работать разработанное
ПО, была выбрана модульная архитектура приложения. Разработанные модули были спроектированы максимально независимыми.
Также интерфейс модулей, отвечающих за тестирование устройств максимально унифицирован. Функции настройки устройств были
вынесены в отдельные программы для лучшего абстрагирования модулей системы. Все вышеописанные решения
позволили спроектировать легко расширяемую систему.

Ниже будет приведено описание нескольких наиболее важных алгоритмов системы.

\subsection{Управляющий модуль}
Данный модуль управляет процессом тестирования всех подключенных устройств, поэтому рассмотрение работы данного модуля
представляет особый интерес.
Работа модуля начинается с составления дерева подключенных устройств. Для этого используется функция
\texttt{loadDevices}, которая вызывается в процессе работы конструктора объекта класса\break \texttt{OfflineFuncControl}.
Данная функция сначала производит формирование групп подключенных устройств.

\medskip
\begin{minted}{c++}
m_pTreeDevice->clear();

QList<quint8> groups = getListGroupsDevices();
QHash<quint8, QTreeWidgetItem*> groupWidgetHash;

for (quint8 i = 0; i < groups.size(); i++) {

	QTreeWidgetItem* pItemGroup = new QTreeWidgetItem(m_pTreeDevice);
	quint8 groupId = groups[i];
	groupWidgetHash.insert(groupId, pItemGroup);
	QString groupName = getNameGroupDevice( groups[i] );

	QFont f = pItemGroup->font(0);
	f.setBold(true);
	pItemGroup->setFont(0, f);
	pItemGroup->setText(0, groupName);
	pItemGroup->setSizeHint(0, QSize(0, 32));
	m_pTreeDevice->insertTopLevelItem(0, pItemGroup);
	pItemGroup->setExpanded(true);
	Qt::ItemFlags flags = pItemGroup->flags();
	flags |= Qt::ItemIsUserCheckable;

	pItemGroup->setFlags(flags);
	pItemGroup->setCheckState(0, Qt::Checked);
	pItemGroup->setData(0, Qt::UserRole, Qt::Checked);
	pItemGroup->setData(1, Qt::UserRole, 0);


	pItemGroup->setHidden(true);
}
\end{minted}
\medskip

В начале данного алгоритма происходит получение списка групп\break устройств. После полученные группы добавляются к вершине
дерева\break устройств, происходит настройка соответствующим группам элементам интерфейса.

После добавление групп в дерево устройств проводится добавление подключенных устройств в группы.
Согласно алгоритмам, схожим с приведенным в листинге, производится поиск сетевых и
периферийных устройств.

Процесс прохождения тестирования устройств проходит следующим образом. После нажатия кнопки <<Старт>> срабатывает
происходит вызов метода \texttt{onStart}, который отвечает за процесс тестирования.
\medskip
\begin{minted}{c++}
if (m_bStartTest)
	return;
m_bStartTest = true;
m_pBtStart->setEnabled(false);
m_pBtPrint->setEnabled(false);
m_pBtSettings->setEnabled(false);
m_pBtJournal->setEnabled(false);
QTreeWidgetItemIterator it(m_pTreeDevice);

JournalEntry journalEntry;
QString sRez;
\end{minted}
\medskip

Данный фрагмент кода служит для деактивации некоторых элементов интерфейса на время тестирования и получения указателя
на дерево\break устройств. Объект \texttt{JournalEntry} будет использован для хранения данных о результатах тестирования и
записи их в журнал.
\medskip
\begin{minted}{c++}
while (*it) {
	sRez = "";
	QTreeWidgetItem * item = *it;
	if ((item->checkState(0) != Qt::Checked) || item->childCount() || item->isHidden())
	{
		++it;
		continue;
	}

	item->setForeground(1, QBrush(Qt::black));
	item->setText(1, ID_FUNC_FONE_2 + "...");

	quint32 idItem = item->data(1, Qt::UserRole).toUInt();

	m_pTreeDevice->clearSelections();
	m_pTreeDevice->selectItemById(idItem, true);

	QTest::qWait(500);

	QString sNameDevise = item->text(0);
	QString sNameDeviseParent = item->text(0);

	quint8 deviceId = item->data(1, Qt::UserRole).toUInt();

	quint8 rez = 0;
\end{minted}
\medskip

Процесс обхода дерева устройств происходит внутри цикла. Устройства, проверка которых не требуется, группы устройств,
спрятанные устройства  не участвуют в процессе тестирования. Далее происходит изменение элементов графического
интерфейса, соответствующих устройству, которое проходит тестирование в данный момент, для информирования пользователя о
статусе процесса тестирования. Для предотвращения частого изменения элементов графического интерфейса добавлена
небольшая задержка. Также происходит получение информации о выбранном устройстве и соответствующей ему группе.
\medskip
\begin{minted}{c++}
switch (deviceId)
{
	case 16:
		{
			VTest_R181 test(this);
			rez = test.test(deviceId, sRez);
			break;
		}
	case 11:
		{
			VTest_MeteoWXT520 test(this);
			rez = test.test(sRez);
			break;

		}
	case 12:
		{
			VTest_BINS3 test(this);
			rez = test.test(sRez);
			break;

		}
	case 17:
		{
			VTest_GPS test(this);
			rez = test.test(sRez);
			break;
		}
	case 18:
		{
			QTestPrinter test(this);
			rez = test.test(sRez);
			break;
		}
	default:
			break;
}
\end{minted}
\medskip

Для каждого устройства используется соответствующий объект для\break проведения тестирования. Метод \texttt{test} отвечает
непосредственно за тестирование выбранного устройства. Результат тестирования сохраняется в переменную \texttt{rez}.
Данное значение будет использоваться в дальнейшем при формировании результатов тестирования.

Далее происходит вывод соответствующей результатам тестирования устройства информации на экран и добавление результатов
тестирования в запись. После этого цикл повторяется для следующего устройства. После прохождения тестирования всеми
устройствами происходит сохранение результатов тестирования в журнал и возобновление доступности кнопок приложения.

\subsection{Модуль тестирования БИНС}
Данный модуль осуществляет тестирование БИНС. Проводится проверка подключения БИНС, происходит считывание и анализ
сообщений статуса и навигационных сообщений БИНС. Рассмотрим данный алгоритм подробнее.

При создании объекта вызывается конструктор, который проводит инициализацию флагов получения сообщений и привязывает
метод для обработки данных сокета к сигналу наличия данных в сокете.
\medskip
\begin{minted}{c++}
m_bReceiveMess01 = false;
m_bReceiveMess81 = false;
connect(&m_sockReceive, SIGNAL(readyRead()), SLOT(onReadFromSocket()));
\end{minted}
\medskip

Метод \texttt{test} отвечает за управление процессом тестирования БИНС. Метод начинает работу с проверки настроек и
параметров подключенного устройства. В ходе проверки вся полученная информация заносится в журнал.
\medskip
\begin{minted}{c++}
sRez.clear();

sRez = "<b>" + getNameDevice(ID_DEVICE_BINS3) + "</b>";
sRez += CR;

_SETT_ARM sett;
if (!getSettARM(sett))
{
	sRez += CR;
	sRez += tr("Не заданы настройки подключения INS!");
	return 10;
}
\end{minted}
\medskip

Остальные настройки и параметры, такие как параметры подключения устройства, IP адрес, проверяются аналогичным образом.

При удачном подключении БИНС после проверки состояния устройства программа начинает считывать и анализировать полученные
данные, для ожидания окончания сбора необходимых пакетов используется\break \texttt{QEventLoop}.
\medskip
\begin{minted}{c++}
QEventLoop ev;

QTimer::singleShot(5000, &ev, SLOT(quit()));
connect(this, SIGNAL(signGetAllMessFromBINS()), &ev, SLOT(quit()));
ev.exec();
\end{minted}
\medskip

Далее полученные дейтаграммы анализируются в методах\break \texttt{decodeMes01} и \texttt{decodeMes81}.

Метод \texttt{onReadFromBINS} проводит разбиение полученных\break дейтаграмм на сообщения и анализ данных сообщений.
\medskip
\begin{minted}{c++}
static QByteArray baRemain;
QByteArray baData = baRemain + datagram;
QList<QByteArray> listMess = Protocol_BINS3::unpackMess(baData, baRemain);

for (quint32 i = 0; i < listMess.size(); i++)
{
	QByteArray baKdg = listMess.at(i);
	Protocol_BINS3::_KDG kdg = Protocol_BINS3::unpackKDG(baKdg);

	if (kdg.typeKDG == Protocol_BINS3::MESS_01)
	{
		m_mes01 = kdg.kdg01;
		m_bReceiveMess01 = true;
	}
	else if (kdg.typeKDG == Protocol_BINS3::MESS_81)
	{
		m_mes81 = kdg.kdg81;
		m_bReceiveMess81 = true;
	}


	if (m_bReceiveMess01 && m_bReceiveMess81)
	{
		emit signGetAllMessFromBINS();
		break;
	}
}
\end{minted}
\medskip

Данный метод производит разбиение полученной дейтаграммы\break \texttt{datagram} на сообщения и формирует список сообщений.
Далее происходит анализ полученных сообщений. Полученное сообщение инкапсулируется в структуру \texttt{kdg} для удобства
доступа к полям сообщения.

Происходит анализ типа полученных сообщений. При получении сообщения с навигационными данными или сообщения с
информацией о статусе устройства происходит установка соответствующего флага и инкапсуляция заголовка сообщения в
соответствующую структуру, используемую при дальнейшем анализе. При получении сообщений двух типов происходит генерация
сигнала \texttt{signGetAllMessFromBINS}. Данный сигнал прерывает \texttt{QEventLoop}.

Методы \texttt{decodeMes81} и \texttt{decodeMes01} служат для анализа сообщений статуса и сообщений с навигационными
данными соответственно.
\medskip
\begin{minted}{c++}
void VTest_BINS3::decodeMes81(bool & bIspr, QString & sRez)
{
bIspr = true;
sRez += CR;
sRez += CR;
sRez += tr("<b>Статус INS:</b>");

sRez += CR;

sRez += tr("Признак калибровки ДПЦ-2: ");
if(m_mes81.calibrate_DPC2 == 0)
	sRez += tr("Не выполнена");
else
	sRez += tr("Выполнена");

sRez += CR;
\end{minted}
\medskip

Метод \texttt{decodeMes81} производит анализ полей сообщения статуса. Вся полученная информация сохраняется для
последующей записи в журнал.

Работа метода \texttt{decodeMes01}, анализирующего сообщения с навигационными данными, аналогична методу
\texttt{decodeMes81}, за исключением\break необходимости преобразования координат в удобную для чтения форму.

\subsection{Модуль тестирования принтера}
Данный модуль используется для проверки корректности настроек\break подключения принтера и проверки качества печати путем
печати тестовой страницы.

Метод \texttt{test} производит проверку параметров подключения устройства, после чего осуществляется настройка
диалогового окна для печати тестовой страницы.
\medskip
\begin{minted}{c++}
QPrinter printer(QPrinter::HighResolution);
printer.setOrientation(QPrinter::Portrait);
printer.setDocName (ID_FUNC9);
QWidget * widg = qobject_cast<QWidget *>(parent());

QPrintPreviewDialog dlgPreview(&printer, widg);
connect(&dlgPreview, SIGNAL(paintRequested(QPrinter * )), this, SLOT(print(QPrinter *)));
dlgPreview.resize(800, 800);
dlgPreview.show();
dlgPreview.exec();

if (QMessageBox::question(0, ID_FUNC9, ID_FUNC24, QMessageBox::Yes, QMessageBox::No) == QMessageBox::Yes)
{
	sRez += CR;
	sRez += tr("Тестовая страница напечатана корректно!");
	return 0;
}

sRez += CR;
sRez += tr("Тестовая страница напечатана некорректно!");

return 1;
\end{minted}
\medskip

Печать страницы осуществляется с помощью средств библиотеки Qt. Объект \texttt{QPrinter} представляет собой виртуальное
устройство печати. Метод \texttt{test} осуществляет настройку параметров печати страницы, после чего происходит
настройка диалогового окна печати. Для генерации тестовой страницы используется метод \texttt{print}, который вызывается
при создании перевью документа, подготовленного для печати. Проверка корректности печати осуществляется оператором.
Результаты проверки вносятся в журнал с помощью соответствующих кнопок \texttt{QMessageBox}. Далее рассмотрим метод,
отвечающий за создание тестовой страницы.
\medskip
\begin{minted}{c++}
void QTestPrinter::print(QPrinter * printer)
{
  printer->setFullPage(false);
  QPainter paint(printer);
  QFont font = paint.font();
  font.setPointSize(16);
  paint.setFont(font);



  qreal left, top, right, bottom;

  printer->getPageMargins (&left, &top, &right, &bottom, QPrinter::DevicePixel);
  QRectF rectPaint = printer->paperRect(QPrinter::DevicePixel);

  QRect rectTitle = QRect(QPoint(rectPaint.left() + left + 10, rectPaint.top() + top + 10), QPoint(rectPaint.right() - right - left - 10, rectPaint.top() + top + rectPaint.height()/15));
  paint.drawRect(rectTitle);

  _SETT_ARM sett;
  getSettARM(sett);

  QString sIzdelie = QString("%1, %2").arg( getNameObject1B12(sett.typeObject)).arg( getNameDevice(sett.idARM));
  paint.drawText(rectTitle, Qt::AlignCenter, QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss") + " " + sIzdelie);

  int i;
  int pointSize = 34;
  int y = rectPaint.height()/15 + top + 20;
  for (i = 0; i < 10; i++)
  {
	  QRect rectText(QPoint(rectPaint.width()/25,y), QPoint(rectPaint.right() - right, y + rectPaint.height()/15));
	  font.setPointSize(pointSize);
	  paint.setFont(font);
	  paint.drawText(rectText, Qt::AlignVCenter | Qt::AlignLeft, ID_FUNC9);
	  y += rectPaint.height()/15;
	  pointSize -= 2;
	  printer->setFullPage(false);

  }

  printer->setFullPage(true);
}

\end{minted}
\medskip

Метод получает указатель на устройство печати типа \texttt{QPrinter}. Данный указатель используется для настройки
параметров печати. Метод производит настройку параметров страницы, настройку используемого шрифта, после чего формирует
место под заголовок страницы. Далее производится заполнение документа тестовыми строками.

\texttt{Модуль тестирования АРМ}
Данный модуль осуществляет проверку состояния подключения к сети всех АРМ, находящихся в машине.
\medskip
\begin{minted}{c++}
quint8 QTestARM::test(quint8 idDevice, QString & sRez) {
	_SETT_ARM sett;
	if (!getSettARM(sett))
		return 10;

	_IP_DEVICE device = sett.shemeLAN.value(idDevice);

	if (!device.idDevice)
		return 10;

	sRez += getNameDevice(device.idDevice);

	if (!device.hashIP.size())
	{
		sRez += CR;
		sRez += tr("Для устройства не заданы интерфейсы подключения к локальной сети!");
		return 10;
	}

	QHashIterator<QString, QString> it(device.hashIP);

	quint8 rez = 0;
	while (it.hasNext())
	{
		it.next();
		QString sLan = it.key();
		QString sIP = it.value();

		sRez += CR;
		sRez += QString("%1 (%2): ").arg(sLan).arg(sIP);
		sRez += CR;

		quint8 rez1 = ping(sIP, sRez);

		if (rez1)
			rez = rez1;

	}

	return rez;
}
\end{minted}
\medskip

Метод осуществляет получение настроек АРМ и чтение схемы сети. На основе полученных данных происходит проверка
корректности настроек АРМ. Если сетевые интерфейсы настроены корректно, происходит проверка состояния соседних АРМ путем
посылки ping сообщений.

\subsection{Модуль журналирования}
Данный модуль отвечает за сохранения результатов тестирования в формате JSON. Формат JSON был выбран для хранения файлов
журнала из-за того, что результирующий файл легко читается человеком. Также данный формат помогает легко выполнять
сериализацию сложных структур данных. Рассмотрим работу функции, выполняющей сохранение данных в журнал.
\medskip
\begin{minted}{c++}
void Journal::store(JournalEntry journalEntry)
{
	QString sDir = QApplication::applicationDirPath();
	QString filename = sDir + "/Journal/data/" + journalEntry.getDate().toString("yyyy-MM") + ".json";
	QFile file(filename);
	if (!file.exists()) {
		file.open(QIODevice::ReadWrite);
		QTextStream stream(&file);
		stream.setCodec("UTF-8");
		stream << "[\n" << asJSON(journalEntry) << "\n]";
		stream.flush();
		file.close();
	} else {
		file.open(QIODevice::ReadOnly);
		QTextStream inStream(&file);
		inStream.setCodec("UTF-8");
		QString jsonArray = inStream.readAll();
		file.close();
		QString jsonJournalEntry = asJSON(journalEntry);
		appendEntryToArray(jsonArray, jsonJournalEntry);
		file.open(QIODevice::WriteOnly);
		QTextStream outStream(&file);
		outStream.setCodec("UTF-8");
		outStream << jsonArray;
		outStream.flush();
		file.close();
	}
}
\end{minted}
\medskip

Данный метод отвечает за запись сформированной \texttt{JournalEntry} в JSON файл. Каждый файл содержит данные о всех
тестах, проведенных за соответствующий месяц. В случае наличия файла с результатами предыдущих тестов за текущий месяц
результаты текущего теста добавляются к массиву со всеми записями за месяц. В случае отсутствия файла с предыдущими
записями происходит создание нового файла и добавление в него данных.
